{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Handling Geographic 'Poly' Data (Shapefiles) in R\"\nauthor: \"Adam B. Smith\"\ndate: \"June 14, 2018\"\noutput: word_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\nIn this tutorial we will manipulate geographic \"poly\" data (e.g., polygons, lines, and points, often stored in *shapefile* format).  You will learn:\n\n* How to load/save a shapefile \n* How to select components of and crop a shapefile\n* How to overlay shapefiles so information from one is transferred to another\n# Some common geographic operations like calculating area.\n* How to make a nice-ish map\n\n# Libraries\nPlease install then load these packages:\n\n```{r, echo=FALSE}\n.libPaths('C:/Ecology/Drive/R/libraries')\n```\n```{r, message=FALSE}\nlibrary(sp)         # classes for spatial objects\nlibrary(raster)     # manipulates rasters\nlibrary(dismo)      # species distribution modeling\nlibrary(rgeos)      # common geographic calculations\nlibrary(geosphere)  # for calculating geographic distances\nlibrary(geojsonio)  # for obtaining GeoJSON geographic data\nlibrary(scales)     # for rescaling data\n```\nYou will also need the `omnibus`, `enmSdm`, and `legendary` packages, but these are available only from GitHub:\n```{r, eval=FALSE}\ninstall.packages('devtools') # if you haven't done this already\n\nlibrary(devtools)\ninstall_github('adamlilith/omnibus')\ninstall_github('adamlilith/legendary')\ninstall_github('adamlilith/enmSdm')\n```\n```{r}\nlibrary(omnibus)\nlibrary(legendary)\nlibrary(enmSdm)\n```\n\n# Loading, selecting, projecting, and plotting shapefiles\nWe will do our analysis on the US state of Missouri. To start we'll download data for the entire US from the Database of Global Administrative Areas (GADM).\n\n```{r, message=FALSE}\ngadm <- raster::getData('GADM', country='USA', level=2)\nplot(gadm)\n```\n\nThis is a little too much--let's choose just Missouri.\n```{r}\nmo <- gadm[gadm$NAME_1 == 'Missouri', ]\nplot(mo)\n```\n\nNote that the Missouri object is also a data frame, meaning you can do most operations on it that you could do on a data frame:\n```{r}\nnrow(mo)\nnames(mo)\n```\n\nCalling just the name of the object will give you important information about it:\n```{r}\nmo\n```\n\nHere you can see the object type (`SpatialPolygonsDataFrame`), number of \"sub-polygons\" (counties in this case--there are 114 of them), the geographic extent, coordinate reference system (more on this immediately below), number of columns (15), and an abbreviated version of the data table (the data frame part).\n\nIf you are using multiple map objects to do an analysis, you almost always need to put them into a common **coordinate reference system** (CRS), which is a particular geometric convention used to locate things (e.g., x and y coordinates or longitude and latitude). Map objects sometimes also have a **projection**, which is a transformation from a plane (i.e., your screen) to a simulated sphere or ellipsoid (i.e., the Earth).  CRSs and projections are specified by a **proj4 string** which you can see by calling the name of the object (as above) or using\n```{r}\nraster::projection(mo)\n```\n\nThis particular proj4 string is for the \"WGS84\"\" CRS, which used quite often. It's an *unprojected* CRS, meaning that it forces the map to look good on a flat surface (your screen), but it doesn't accurately reflect distance, area, or angles.  Projected CRSs can correct *one* of these aspects at a time, but none can correct more than one. We will project the Missouri polygon object to the Albers North America Equal-Area CRS.  The proj4 string for this is\n```{r}\nenmSdm::getCRS('albersNA')\n```\n\nSo let's project Missouri to this CRS. (Note: I have found that you usually *must* put the package (`sp::`) part before the function call `spTransform` because there is a function with the same name in the `rgdal` library which is often automatically loaded when you use the packages we loaded above.)\n```{r}\nmo <- sp::spTransform(mo, getCRS('albersNA', TRUE))\nplot(mo)\n```\n\n\nThe projected map of Missouri looks only *slightly* different from the unprojected map, but this is because the state is fairly small compared to the curvature of the Earth.\n\n##Creating a \"points\"\" shape from raw data\nWe will also use a database of major Ozarkian springs surveyed by Julian Steyermark in the 1920s-2030s. You can obtain it from [GitHub](https://github.com/adamlilith/rTutorials/blob/master/steyermarkSprings.csv). Unzip this and load it into `R` as a data frame.\n\n```{r, echo=FALSE}\nsteyer <- read.csv('C:/Ecology/Drive/Research/Steyermark Resurvey Project/Data/Steyermark Springs 2014-07-08 Updated taxonomy.csv', as.is=TRUE)\n```\n```{r, eval=FALSE}\nsteyer <- './Steyermark Springs 2014-07-08 Updated taxonomy.csv', as.is=TRUE)\nhead(steyer)\n```\n\nThe fields `spring1`, `spring2`, etc. are the name of the spring (sometimes there is more than one name), `county` is county, `latMoDnr` and `longMoDnr` are the latitude and longitude of the springs obtained from the Missouri Department of Natural Resources, `richness` is number of plant taxa in the springs, and the remainder of the columns are presence/absence of the given taxa in the springs. Please be aware that subsequent work by George Yatskievych (author of the revised version of Steyermark's *Flora of Missouri*, has found that Steyermark mis-identified some plants, but for now we'll use the Steyermark's data as-is. \n\nLet's convert this to a **SpatialPointsDataFrame** (a points \"shapefile\"):\n```{r, error=TRUE}\nsprings <- sp::SpatialPointsDataFrame(\n    coords=cbind(steyer$longMoDnr, steyer$latMoDnr),\n    data=steyer,\n    proj4string=enmSdm::getCRS('wgs84', TRUE)\n)\n```\n\nOops! I was not able to locate some of the springs, so they don't have coordinates (in georeferencing the springs, I found Steyermark's \"compass\" didn't always seem to point north...). In this case I happen to know the coordinates have an unprojected (WGS84) CRS. Also, note that unlike how we often say \"latitude and longitude,\" in `R` we put longitude first (the x-coordinate) and latitude second (the y-coordinate).\n```{r}\nsteyer <- steyer[!is.na(steyer$longMoDnr), ]\n\nsteyer <- sp::SpatialPointsDataFrame(\n    coords=cbind(steyer$longMoDnr, steyer$latMoDnr),\n    data=steyer,\n    proj4string=enmSdm::getCRS('wgs84', TRUE)\n)\n\nsteyer\n```\n\nLet's plot the springs!\n\n```{r}\nplot(mo)\npoints(steyer)\n```\n\nWeird!  What happened?  Here's a hint: compare the CRS of the two objects:\n```{r}\nraster::projection(mo)\nraster::projection(steyer)\n```\n\nWe need to project the `steyer` spatial object to the Albers North America Equal-Area CRS. We can get the proj4 string from the `enmSdm::getCRS()` function or from the Missouri object directly using `raster::projection()`:\n```{r}\nsteyer <- sp::spTransform(steyer, raster::projection(mo))\n\nplot(mo)\npoints(steyer)\n```\n\n##Work with GeoJSON objects, do overlays, and calculate polygon area\nNow let's get a data set for **all* (known) springs in Missouri. We can download this from the Missouri DNR's website [manually](https://data-msdis.opendata.arcgis.com/datasets/0745217e2674450e8afc6a40fa4201ff_0) or do it in `R` using a GeoJSON service. \n```{r}\nsprings <- geojsonio::geojson_read('https://opendata.arcgis.com/datasets/0745217e2674450e8afc6a40fa4201ff_0.geojson', what='sp')\n\nsprings\n```\n\nGeoJSON objects are always assumed to come in the WGS84 CRS.\n```{r}\nsprings <- sp::spTransform(springs, raster::projection(mo))\n\nplot(mo, border='gray')\npoints(springs, col='blue')\n```\n\nThat is a lot of springs, especially in the Ozarks! But is spring **density** really higher there? Now, let's calculate the density of springs in each county. First, we'll calculate the area of each county, then count how many springs there are in each.\n```{r}\nareas <- rgeos::gArea(mo)\nareas\n```\n\nThat didn't seem to work... the problem is that it gave us the area of all of Missouri, not each county. To get the area of each county, use:\n```{r}\nareas <- rgeos::gArea(mo, byid=TRUE)\nhead(areas)\n```\n\nThere is one value per county. You can infer this from:\n```{r}\nlength(areas)\nnrow(mo)\n```\n\n**Special note**: *In this case* we are safe assuming that each value here represents a single county. *However*, some states have counties represented by multiple polygons, so you would get one value per polygon.  You would have to do a **union** operation which merges polygons (see `?rgeos::gUnaryUnion` or `?rgeos::gUnion`).\n\nWhat are the units of area? You can find out by looking at the CRS of the Missouri object:\n```{r}\nraster::projection(mo)\n```\n\nDo you see the part that says `+units=m`? This means that the map units are meters, so area is in meters-squared. Let;'s convert to km^2 and add this as a field to the springs shape object:\n```{r}\nareas <- areas / 1000000\nmo$area_km2 <- areas\nhead(mo)\n```\n\nNow we'll do an **overlay** operation that uses one spatial object to extract data from another.\nWe'll do this to calculate the density of springs in each county.\n```{r}\ncountiesBySprings <- sp::over(springs, mo)\n\nhead(countiesBySprings)\n\nnrow(countiesBySprings)\nnrow(springs)\n```\n\nYou can see there's one line per spring, and that lines repeat. In this case the lines in `countiesBySpring` indicate which county each of the ~4500 springs is in. We can now use this to enumerate the number of springs per county and calculate their density.\n```{r}\nmo$springs <- NA\ncounties <- unique(mo$NAME_2)\n\nfor (county in counties) {\n  \n  numSprings <- sum(countiesBySprings$NAME_2 == county, na.rm=TRUE)\n  mo$springs[mo$NAME_2 == county] <- numSprings\n  \n}\n\nmo$springDensity_numPerKm2 <- mo$springs / mo$area_km2\nhist(mo$springDensity_numPerKm2, breaks=20, xlab='Spring Density (# / km2)', main='')\n```\n\nMost counties have low spring density. To visualize this, let's create a **chloropleth**, a map with areas colored or shaded in proportion to some numerical value (e.g., the density of springs). We will first have to make a color scale based on rescaling spring density.\n\n```{r}\n# rescale spring density to range [0, 100]\nspringDensity <- mo$springDensity_numPerKm2\nspringDensityScaled <- springDensity / max(springDensity)\nspringDensityScaled <- round(100 * springDensityScaled)\n\n# get grayscale palette for spring density\nshades <- rev(gray.colors(101, start=0, end=1))\ncountyCols <- shades[springDensityScaled + 1]\n```\nLet's do the same for taxon richness in Steyermark's spring data.\n```{r}\nrichness <- steyer$richness\nrichnessScaled <- richness / max(richness)\nrichnessScaled <- ceiling(100 * richnessScaled)\n\nshades <- rev(heat.colors(101))\nsteyerCols <- shades[richnessScaled + 1]\n```\n\nNow, let's make a map that displays:\n* Missouri counties with shade indicative of spring density  \n* A legend for spring density  \n* Steyermark's springs with the size of each symbols proportional to number of plant taxa he found in each spring\n\n```{r, fig.width=6.5}\nplot(mo, col=countyCols, border='gray')\npoints(springs, col='blue', pch='.')\npoints(steyer, pch=21, cex=steyer$richness / 5, bg=scales::alpha(steyerCols, 0.5))\n\n# create legend for Steyermark springs\nlabs <- pretty(richness)\n\nlegendary::legendGrad(\n    'left',\n    inset=-0.15,\n    height=0.8,\n    width=0.2,\n    gradAdjX=c(0.3, 0.5),\n    gradAdjY=c(0.3, 0.9),\n    labels=labs,\n    labAdj=0.6,\n    col=rev(heat.colors(10)),\n    title='Richness',\n    boxBg=NULL,\n    boxBorder=NULL,\n    xpd=NA\n)\n\n# create legend for counties\nlabs <- pretty(springDensity)\n\nlegendary::legendGrad(\n    'left',\n    height=0.8,\n    width=0.2,\n    gradAdjX=c(0.3, 0.5),\n    gradAdjY=c(0.3, 0.9),\n    labels=labs,\n    labAdj=0.6,\n    col=c('white', 'black'),\n    title='Springs\\n(# / km2)',\n    boxBg=NULL,\n    boxBorder=NULL,\n    xpd=NA\n)\n```\n\nFinally, we can save the Steyermark spatial object.  The smallest kind of file will be a normal `.RData` file (or `.RDS` file):\n```{r, eval=FALSE}\nsave(steyer, file='./Steyermark Springs.Rdata')\n```\n\nBut we can also save it in \"shapefile\" format for use in a dedicated GIS program like ArcMap or QGIS:\n```{r, eval=FALSE}\ndismo::shapefile(steyer, 'steyermarkSprings')\n```\n\n**FINIS!**",
    "created" : 1529076841682.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2990190411",
    "id" : "6BA9791F",
    "lastKnownWriteTime" : 1529086943,
    "last_content_update" : 1529086943630,
    "path" : "C:/ecology/Drive/R/rTutorials/shapefilesTutorial.Rmd",
    "project_path" : "shapefilesTutorial.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}